import sys, os
import string, math, re, random
import json, time
from glob import glob
from datetime import datetime
import numpy as np
import pandas as pd

user = os.getlogin()
sys.path.append('C:/Users/%s/Dropbox/Instruments cloud/Robotics/Unchained BK/AS Scripts/API Scripts' % user)

from a10_sila import CustomAS10 
from CustomService import *


#######################################################################################################################

# red side is the sample collection side of the permeation cells, it is *1 and *2
# green side is the feed side of the permeation cells, it is *3 and *4

class AMEWS:

    def __init__(self):

        self.verbose = 0

        # self.cells = ["A1","B1","C1","A2", "B2", "C2"] # red (sampled) side  ============== six cells
        self.cells = ["A1","B1"]
        self.sources = "AMEWS_6cell_input.csv"
        self.path = os.getcwd()
        self.AS = True # run AS
        self.rack = 90 # 90 tube rack
        self.blank = True # collect red side blanks first
        self.fictive = 0.1 # uL of fictitous addition to the red side, for container bookkeeping
        self.fill = 1000 # uL fill of the green side
        self.volume = 250 # ul sampling of the red side
        self.chaser = 1000 # uL chaser
        self.delay = 0.10 # minutes to wait after each sampling
        self.laps = 2 # laps of sample collection
        self.aliquots = [250, 125, 60, 30, 15] # uL aliquots for calibrations - adjust
        self.last_container = {} # sample container
        self.last_log = None 
        self.null_prep()
        self.make_lists()
        self.start_sequence()
        self.ld = CustomLS10()
        self.ld.verbose = self.verbose

    def make_lists(self):
        n = len(self.cells)
        self.cells_list = ",".join(self.cells)
        self.counters = [] # green side
        for c in self.cells:
            c_ = "%s%d" % (c[0], 2 + int(c[1:]))
            self.counters.append(c_)
        self.counters_list = ",".join(self.counters)
        if self.verbose: 
            print(">> Sample wells (%d) = %s" %  (n, self.cells_list))
            print(">> Counter wells (%d) = %s" % (n, self.counters_list))

    def null_prep(self):
        self.prep = 0 # holds the initial fill tm.mapping offset
        self.prep_container = {} # pre-sample containers

    def start_sequence(self): # start a sequence of experiments
        self.master_log = []
        self.null_prep()
        self.COUNT =0 # counter of LS calls

# ================================ json serialization =================================

    def to_json(self):
        return {
            "cells": self.cells,
            "sources": self.sources, # name of the input source file
            "path": self.path, # work directory
            "aliquots": self.aliquots,
            "rack": self.rack,
            "blank": self.blank,
            "fictive": self.fictive,
            "fill": self.fill,
            "volume": self.volume,
            "chaser": self.chaser,
            "delay": self.delay,
            "laps": self.laps,
            "do AS": self.AS, 
            "prep": self.prep, # last rack offset
            "prep_container": self.prep_container, # last prep container
            "last_container": self.last_container, # last sample container
            "master log": self.master_log,
            "last ID" : self.ld.ID, # last library ID
            "COUNT": self.COUNT, # last experiment count

            # ld attributes
            "prompts" : self.ld._prompts,   # last prompt input file
            "chem" : self.ld._chem,         # last chem library input file
            "code" : self.ld.last_code,     # last container code
            "AS pause" : self.ld.as_pause,  # AS pause message
            "AS state" : self.ld.as_state,  # AS state
        }

    def from_json(self, j):
        # Populate the class instance from the JSON data (dictionary)
        if self.verbose: 
            print("\n>> JSON input: %s\n" % j)
        self.cells = j.get("cells")
        self.make_lists()
        self.sources = j.get("sources")
        self.path = j.get("path", os.getcwd())
        self.volume = j.get("volume", 250)
        self.aliquots = j.get("aliquots", [self.volume])
        self.rack = j.get("rack", 90)
        self.blank = j.get("blank", True)
        self.fictive = j.get("fictive", 0.01)
        self.fill = j.get("fill", 1000)
        self.chaser = j.get("chaser", 2000)
        self.delay = j.get("delay", 0)
        self.laps = j.get("laps", 3)
        self.AS = j.get("do AS", False)
        self.prep = j.get("prep", 0)
        self.prep_container = j.get("prep_container", {})
        self.last_container = j.get("last_container", {})
        self.master_log = j.get("master log", [])
        self.COUNT = j.get("COUNT", 0)

        # setting ld attributes 
        self.ld.ID = j.get("last ID", 0)
        self.ld.ID_folder()
        self.ld._prompts = j.get("prompts", "")
        self.ld._chem = j.get("chem", "")
        self.ld.last_code = j.get("code", "")


# ====================================== consolidate log files  ===============================================

    def copy_AS_logs(self, ID_fro, ID_to):
        if ID_fro==ID_to: 
            return 0
        d_fro = os.path.join(self.path, str(ID_fro))
        d_to =  os.path.join(self.path, str(ID_to))
        if not os.path.exists(d_to): return 0
        if os.path.exists(d_fro):
            n=0
            for f in os.listdir(d_fro):
                if f.startswith('AS') and 'AS_' not in f:
                   if f.endswith('.csv') or f.endswith('.log'):
                        fro = os.path.join(d_fro, f)
                        to =  os.path.join(d_to, f)
                        shutil.copy(fro, to)
                        n+=1
            if self.verbose: 
                print(">> Copied %d AS logs from ID=%d to ID=%d" % (n, ID_fro, ID_to))
        else: return 0

    def consolidate_AS_logs(self, ID):
        if self.master_log:
            for e in self.master_log:
                self.copy_AS_logs(e["ID"], ID)


##########################################  the common opening steps #####################################################

    def LS_open(self, cells, name = "sampling"): 
    
        self.ld = CustomLS10()
        self.ld.create_lib(name)
        self.ld.disp.COUNT = self.COUNT
        self.COUNT+=1

        print("\n\n")
        print("#" * 80)
        print("#\t\tAMEWS %s" % name.upper())
        print("#" * 80)
        print("\n\n")

        self.ld.add_param("Delay","Time","min")
        self.ld.add_param("StirRate","Stir Rate","rpm")
        self.ld.add_param("Pause","Text","")
        self.ld.get_params() 
    
        # making a substrate library
        self.ld.pt.add("source1","Rack 2x4 20mL Vial","Deck 10-11 Position 2")
        self.ld.pt.add("plate1","Rack 3x4 six Kaufmann H-cells","Deck 12-13 Heat-Cool-Stir 1")

        if 'fill' not in name:
            if self.rack==90: 
                self.ld.pt.add("ICP1","Rack 6x15 ICP robotic","Deck 16-17 Waste 1")
            if self.rack==60:
                self.ld.pt.add("ICP1","Rack 5x12 ICP robotic","Deck 16-17 Waste 1")

        # adding all plates 
        self.ld.add_all_plates()
    
        # adding off deck and plate sources
        self.ld.add_chem(None,"solvent")
    
        # making the transfer map
        if self.verbose: print("\n ==== map from ==== ")
        self.ld.tm.add_from(self.ld.pt,"plate1",cells,0) # by column  red compartments
        self.ld.tm.report_from()

        # input from a CSV file
        f = os.path.join(self.path, self.sources)
        self.ld.log_input(f) # input from a CSV table

        self.ld.Stir("plate1", 500) # rpm
        self.ld.dummy_fill("plate1", 1e5) # 100 mL

        # sourcing and dispensing chemicals
        source = self.ld.tm.full_plate(self.ld.pt, "source1", 1)

    def LS_to(self): 
   
        if self.verbose: 
            print("\n ==== map to ==== ")
            print("\n>> ICP rack offset = %d\n" % self.prep)

        self.ld.tm.add_to(self.ld.pt, "ICP1", "full", 1, self.prep) # tube rack, 1 by row, self.prep is offset
        self.ld.tm.report_to()
    
        self.ld.tm.map(0)   # no randomization of sampling 

        self.ld.tm.to_df()
        #print(self.ld.tracker.samples)

################################################## experiment sequence ###########################################################################


    def LS_blank(self): # collection of blank samoles from the red side

        if not self.blank: return 0

        self.LS_open(self.cells_list, "sample blanks")
        self.LS_to()

        #print(self.ld.tracker.samples)
        # transfer from source to cell compartments, red is "symbolic" transfer

        i=0
        for plate, well, _ in self.ld.tm.lib_from:
            self.ld.dispense_chem(self.ld.input_names[i],
                             plate,
                             well,
                             self.fictive, # added volume
                             "skip", # "1tip", # actual addition
                             True # add to sourcing log
                             )
            i+=1

        self.prep += i
        self.ld.tm.mapping = self.ld.tm.mapping[0:i]
        self.ld.tm.to_df()

        # transferring using the transfer map
        self.ld.transfer_replace_mapping(self.volume, # volume
                                    self.chaser, # chaser volume
                                    "1tip",
                                    )
       
        #self.ld.Pause("plate1", 20) # message

        self.ld.finish()       # writing into the database and creating log files and xml files for AS  

        c= self.ld.make_container("ICP1", "blank")

        self.prep_container = self.ld.update_container(self.prep_container, c)
        self.ld.save_container(self.prep_container, image=False)

        self.last_ld = self.ld

        return self.ld.ID


#=============================================================================================================


    def LS_fill(self):

        self.LS_open(self.counters_list, "fill cells")

        i=0
        for plate, well, _ in self.ld.tm.lib_from:
            self.ld.dispense_chem(self.ld.input_names[i],
                             plate,
                             well,
                             self.fill, # added volume
                             "1tip", # "1tip", # actual addition
                             True # add to sourcing log
                             )
            i+=1

        self.ld.finish()       # writing into the database and creating log files and xml files for AS


        return self.ld.ID

#=============================================================================================================

    def LS_calibrate(self):

        if len(self.aliquots)==0: return 0

        self.LS_open(self.counters_list, "calibration sampling")
        self.LS_to()

        #print(self.ld.tracker.samples)
        # transfer from source to cell compartments, red is "symbolic" transfer

        i=0
        for plate, well, _ in self.ld.tm.lib_from:
            self.ld.dispense_chem(self.ld.input_names[i],
                             plate,
                             well,
                             self.fill, # added volume
                             "skip", # "1tip", # actual addition
                             True # add to sourcing log
                             )
    
        # transferring using the transfer map

        volumes=[]
        i=0
        for a in self.aliquots:
           for c in self.counters:
               if i<len(self.ld.tm.mapping):
                   volumes.append(a)
                   i+=1

        self.prep += i
        self.ld.tm.mapping = self.ld.tm.mapping[0:i]
        self.ld.tm.to_df()

        self.ld.transfer_replace_general(volumes, # volumes
                                        self.chaser, # chaser volume
                                        "1tip"
                                        ) 
       
        #self.ld.Pause("plate1", 20) # message
        # self.ld.Stir("plate1", 0) # rpm

        self.ld.finish()       # writing into the database and creating log files and xml files for AS  

        c = self.ld.make_container("ICP1", "calibration")
        self.prep_container = self.ld.update_container(c, self.prep_container)
        self.ld.save_container(self.prep_container, image=False)

        return self.ld.ID

#=============================================================================================================

    def LS_sample(self):

        self.LS_open(self.cells_list, "farm walkthrough sampling")
        self.LS_to()

        # "fictive transfer from source to cell compartments
        i = 0
        for plate, well, _ in self.ld.tm.lib_from:
            self.ld.dispense_chem(self.ld.input_names[i],
                             plate,
                             well,
                             self.fictive, # fictive added volume to indicate constitution
                             "skip", # skip addition
                             False # add to sourcing log
                             )
            i+=1
    
        # transferring using the transfer map
        self.ld.transfer_replace_mapping(self.volume, # volume
                                    self.chaser, # chaser volume
                                    "1tip",
                                    self.delay, # delay in min
                                    ) 
       
        #self.ld.Pause("plate1", 20) # code for stirring off
        #self.ld.Pause("plate1", 1100) # remove and replace rack
        #self.ld.Stir("plate1", 0) # rpm

        self.ld.finish()       # writing into the database and creating log files and xml files for AS  

        c = self.ld.make_container("ICP1", "analyte")
        if self.prep: 
            c = self.ld.update_container(c, self.prep_container)
        self.ld.save_container(c)
        self.last_container=c

        self.null_prep()

        return self.ld.ID

###########################################################################################################################

    def AS_execute(self, category): # general execurtion and logging routine

        flag=0
        self.last_log = None
        r = {"ID" : self.ld.ID, "category" : category, "container" : self.ld.last_code,  "AS log" : None}

        if self.AS:
           if not self.ld.as_prep(): 
                #self.ld.as_run_paused()
                #print("\n\n********************  CONTROL BACK *******************************\n\n")
                #self.ld.as_run_resume(False) # ignore other pauses
                self.ld.as_run()
                self.ld.as_finish()
                self.ld.smtp.alert("run %d finished with state %s" % (self.ld.ID, self.ld.as_state))
                self.last_log =  self.ld.as10.log
                r["AS log"] = self.last_log
                flag=1

        self.master_log.append(r)
        self.renew_AS_log()
        return flag

    def renew_AS_log(self):
        f = os.path.join(self.ld.dir,"AS_sequence_log.csv")
        df = pd.DataFrame(self.master_log)
        df.to_csv(f, index=False)
        print("\n>> Saved master log in file %s\n" % f)
        print(df)

    def AS_start(self):  # start sequence
       self.start_sequence()
       self.aliquots = [self.volume/2]
       return self.to_json()

    def AS_blank(self, j): # collect blanks
       self.from_json(j)
       self.LS_blank()
       self.AS_execute("blank")
       return self.to_json()

    def AS_fill(self, j): # collect feeds
       self.from_json(j)
       self.LS_fill()
       self.AS_execute("fill")
       return self.to_json()

    def AS_calibrate(self, j): # fill feed sides
       self.from_json(j)
       if self.LS_calibrate():
          self.AS_execute("calibrate")
       return self.to_json()

    def AS_sample_first(self, j): # collect samples to complete the first rack
       self.from_json(j)
       self.LS_sample()
       self.AS_execute("rack 1")
       return self.to_json()

    def AS_sample_next(self, j, lap): # all subsequent sample collections
       self.ld = CustomLS10()
       self.from_json(j)
       if lap==1: # the second lap, full rack
            ID = self.LS_sample()
            self.consolidate_AS_logs(ID)
       else:
           c= self.last_container
           if c:
               c = self.ld.timestamp_container(c) # use the same 
               self.ld.save_container(c)
       self.AS_execute("rack %d" % (lap+1))
       return self.to_json()

    def full_sequence(self): # example of the full sequence without external calls
        info = self.AS_start()
        info = self.AS_blank(info)
        info = self.AS_fill(info)
        info = self.AS_calibrate(info)

        laps = info.get("laps", 3)

        for lap in range(laps):
            print("\n\n################################# Sampling lap %d ######################################\n\n" % (lap+1))
            if lap: 
                info = self.AS_sample_next(info, lap)
            else:    
                info = self.AS_sample_first(info)


###############################################################################################################################


if __name__ == "__main__":

     x1 = AMEWS()
     x1.full_sequence()